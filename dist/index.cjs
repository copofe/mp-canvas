"use strict";class RObject{constructor(t){this.setOptions(t)}_set(t,s){this[t]=s}set(t,s){typeof t=="object"?this._setObject(t):this._set(t,s)}_setObject(t){for(const s in t)this.set(s,t[s])}_setOptions(t){for(const s in t)this.set(s,t[s])}setOptions(t,s){this._setOptions(Object.assign(s||{nDpr:1,left:0,top:0,width:0,height:0},t))}xDpr(t){return t*this.nDpr}new(t,s){return{left:this.left,top:this.top,nDpr:this.nDpr,width:this.width,height:this.height,canvas:s?.canvas,...t}}}function hue2rgb(a,t,s){return s<0&&(s+=1),s>1&&(s-=1),s<1/6?a+(t-a)*6*s:s<1/2?t:s<2/3?a+(t-a)*(2/3-s)*6:a}function hexify(a){const t=a.toString(16).toUpperCase();return t.length===1?`0${t}`:t}const l=/^rgba?\(\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*(?:\s*,\s*((?:\d*\.?\d+)?)\s*)?\)$/i,m=/^hsla?\(\s*(\d{1,3})\s*,\s*(\d{1,3}\%)\s*,\s*(\d{1,3}\%)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)$/i,b=/^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i;class Color{constructor(t){if(!t)this.setSource([0,0,0,1]);else if(t instanceof Color)this.setSource([...t._source]);else if(Array.isArray(t)){const[s,i,r,e=1]=t;this.setSource([s,i,r,e])}else this.setSource(this._tryParsingColor(t))}_tryParsingColor(t){return t==="transparent"?[255,255,255,0]:Color.sourceFromHex(t)||Color.sourceFromRgb(t)||Color.sourceFromHsl(t)||[0,0,0,1]}_rgbToHsl(t,s,i){t/=255,s/=255,i/=255;const r=Math.max(t,s,i),e=Math.min(t,s,i);let n,o;const c=(r+e)/2;if(r===e)n=o=0;else{const h=r-e;switch(o=c>.5?h/(2-r-e):h/(r+e),r){case t:n=(s-i)/h+(s<i?6:0);break;case s:n=(i-t)/h+2;break;case i:n=(t-s)/h+4;break}n/=6}return[Math.round(n*360),Math.round(o*100),Math.round(c*100)]}getSource(){return this._source}setSource(t){this._source=t}toRgb(){const t=this.getSource();return`rgb(${t[0]},${t[1]},${t[2]})`}toRgba(){const t=this.getSource();return`rgba(${t[0]},${t[1]},${t[2]},${t[3]})`}toHsl(){const t=this.getSource(),s=this._rgbToHsl(t[0],t[1],t[2]);return`hsl(${s[0]},${s[1]}%,${s[2]}%)`}toHsla(){const t=this.getSource(),s=this._rgbToHsl(t[0],t[1],t[2]);return`hsla(${s[0]},${s[1]}%,${s[2]}%,${t[3]})`}toHex(){const[t,s,i]=this.getSource();return`${hexify(t)}${hexify(s)}${hexify(i)}`}toHexa(){const t=this.getSource();return`${this.toHex()}${hexify(Math.round(t[3]*255))}`}setAlpha(t){const s=this.getSource();return s[3]=t,this.setSource(s),this}static fromRgb(t){return Color.fromRgba(t)}static fromRgba(t){return new Color(Color.sourceFromRgb(t))}static sourceFromRgb(t){const s=t.match(l);if(s){const i=parseInt(s[1],10)/(/%$/.test(s[1])?100:1)*(/%$/.test(s[1])?255:1),r=parseInt(s[2],10)/(/%$/.test(s[2])?100:1)*(/%$/.test(s[2])?255:1),e=parseInt(s[3],10)/(/%$/.test(s[3])?100:1)*(/%$/.test(s[3])?255:1);return[i,r,e,s[4]?parseFloat(s[4]):1]}}static fromHsl(t){return Color.fromHsla(t)}static fromHsla(t){return new Color(Color.sourceFromHsl(t))}static sourceFromHsl(t){const s=t.match(m);if(!s)return;const i=(parseFloat(s[1])%360+360)%360/360,r=parseFloat(s[2])/(/%$/.test(s[2])?100:1),e=parseFloat(s[3])/(/%$/.test(s[3])?100:1);let n,o,c;if(r===0)n=o=c=e;else{const h=e<=.5?e*(r+1):e+r-e*r,p=e*2-h;n=hue2rgb(p,h,i+1/3),o=hue2rgb(p,h,i),c=hue2rgb(p,h,i-1/3)}return[Math.round(n*255),Math.round(o*255),Math.round(c*255),s[4]?parseFloat(s[4]):1]}static fromHex(t){return new Color(Color.sourceFromHex(t))}static sourceFromHex(t){if(t.match(b)){const s=t.slice(t.indexOf("#")+1),i=s.length===3||s.length===4,r=s.length===8||s.length===4,e=i?s.charAt(0)+s.charAt(0):s.substring(0,2),n=i?s.charAt(1)+s.charAt(1):s.substring(2,4),o=i?s.charAt(2)+s.charAt(2):s.substring(4,6),c=r?i?s.charAt(3)+s.charAt(3):s.substring(6,8):"FF";return[parseInt(e,16),parseInt(n,16),parseInt(o,16),parseFloat((parseInt(c,16)/255).toFixed(2))]}}}class Gradient extends RObject{constructor(t){super(t),this.setOptions(t)}toLive(t){const{x1:s=0,y1:i=0,x2:r=0,y2:e=0,r1:n=0,r2:o=0}=this.coords;let c;if(!this.type)throw new Error("gradient type is undefined");return this.type==="linear"?(console.log(this),c=t.createLinearGradient(this.xDpr(s),this.xDpr(i),this.xDpr(r),this.xDpr(e))):c=t.createRadialGradient(this.xDpr(s),this.xDpr(i),this.xDpr(n),this.xDpr(r),this.xDpr(e),this.xDpr(o)),this.colorStops.map(h=>{const p=h.opacity!==void 0?new Color(h.color).setAlpha(h.opacity).toRgba():h.color;c.addColorStop(h.offset,p)}),c}}class RShape extends RObject{constructor(t){super(t),this.top=0,this.left=0,this.width=0,this.height=0,this.opacity=1,this.stroke=null,this.strokeWidth=1,this.strokeDashArray=null,this.strokeDashOffset=0,this.fill=void 0,this.visible=!0,this.setOptions(t)}_setFillStyles(t,{fill:s}){s&&(typeof s=="string"?t.fillStyle=s:t.fillStyle=new Gradient(this.new(s)).toLive(t))}_renderFill(t){this.fill&&(t.save(),this._setFillStyles(t,this),this.fillRule==="evenodd"?t.fill("evenodd"):t.fill(),t.restore())}_renderStroke(t){}_renderPaintInOrder(t){this.paintFirst==="stroke"?(this._renderStroke(t),this._renderFill(t)):(this._renderFill(t),this._renderStroke(t))}}const kRect=.4477152502,PiBy180=Math.PI/180,degreesToRadians=a=>a*PiBy180;class Circle extends RShape{constructor(t){const s={...t,width:t.radius*2,height:t.radius*2};super(s),this.radius=0,this.startAngle=0,this.endAngle=360,this.left=0,this.top=0,this.setOptions(s)}render(t){t.beginPath(),t.arc(this.xDpr(this.left+this.radius),this.xDpr(this.top+this.radius),this.xDpr(this.radius),degreesToRadians(this.startAngle),degreesToRadians(this.endAngle),!1),this._renderPaintInOrder(t)}}class Ellipse extends RShape{constructor(t){super(t),this.setOptions(t)}render(t){console.log(this);const s=this.xDpr(this.left),i=this.xDpr(this.top),r=this.xDpr(this.rx),e=this.xDpr(this.ry),n=r>e?1/r:1/e;t.beginPath(),t.moveTo(s+r,i);for(let o=0;o<2*Math.PI;o+=n)t.lineTo(s+r*Math.cos(o),i+e*Math.sin(o));t.closePath(),this._renderPaintInOrder(t)}}const isWeb=!!window,loadImage=async(a,t)=>new Promise((s,i)=>{if(isWeb){const r=new Image;r.onload=function(){s({img:r,width:r.width,height:r.height})},r.onerror=i,r.src=a}else{if(!t)throw new Error("canvas is undefined");const r=t.createImage();r.src=a,wx.getImageInfo({src:a,success:e=>{s({img:r,width:e.width,height:e.height})},fail:i})}});class Rect extends RShape{constructor(t){super(t),this.setOptions(t)}render(t){const s=this.xDpr(this.left),i=this.xDpr(this.top),r=this.xDpr(this.width),e=this.xDpr(this.height);if(this.radii){const h=typeof this.radii=="number"?this.xDpr(this.radii):this.radii?.map(this.xDpr);if(t.roundRect){t.roundRect(s,i,r,e,h);return}else throw new Error("not support roundRect, please use rx, ry")}const n=this.rx?Math.min(this.rx,r/2):0,o=this.ry?Math.min(this.ry,e/2):0,c=n!==0||o!==0;t.beginPath(),t.moveTo(s+n,i),t.lineTo(s+r-n,i),c&&t.bezierCurveTo(s+r-kRect*n,i,s+r,i+kRect*o,s+r,i+o),t.lineTo(s+r,i+e-o),c&&t.bezierCurveTo(s+r,i+e-kRect*o,s+r-kRect*n,i+e,s+r-n,i+e),t.lineTo(s+n,i+e),c&&t.bezierCurveTo(s+kRect*n,i+e,s,i+e-kRect*o,s,i+e-o),t.lineTo(s,i+o),c&&t.bezierCurveTo(s,i+kRect*o,s+kRect*n,i,s+n,i),t.closePath(),this._renderPaintInOrder(t)}}class ImageShape extends RShape{constructor(t){super(t),this.src="",this.mode="scaleToFill",this.radius=0,this.setOptions(t)}async render(t){const{src:s,left:i,top:r,width:e,height:n,mode:o,radius:c}=this,h=await loadImage(s,this.canvas),p=e/n;let g=1,u=1;o==="aspectFit"?(g=h.width/h.height<p?e/h.width*h.height/n:1,u=h.width/h.height>p?n/h.height*h.width/e:1):o==="aspectFill"&&(g=h.width/h.height>p?e/h.width*h.height/n:1,u=h.width/h.height<p?n/h.height*h.width/e:1);const x={scaleToFill:[0,0,h.width,h.height],aspectFit:[(h.width-h.width*g)/2,(h.height-h.height*u)/2,h.width*g,h.height*u],aspectFill:[(h.width-h.width*g)/2,(h.height-h.height*u)/2,h.width*g,h.height*u],widthFix:[],top:[(h.width-e)/2,0,e,n],bottom:[(h.width-e)/2,h.height-n,e,n],center:[(h.width-e)/2,(h.height-n)/2,e,n],left:[0,(h.height-n)/2,e,n],right:[h.width-e,(h.height-n)/2,e,n],"top left":[0,0,e,n],"top right":[h.width-e,0,e,n],"bottom left":[0,h.height-n,e,n],"bottom right":[h.width-e,h.height-n,e,n]};c&&(t.save(),new Rect({left:this.left,top:this.top,width:this.width,height:this.height,nDpr:this.nDpr,rx:this.radius,ry:this.radius}).render(t),t.clip()),t.drawImage(h.img,...x[o]||[],this.xDpr(this.left),this.xDpr(this.top),this.xDpr(e||h.width),this.xDpr(n||h.height)),c&&t.restore()}}class Line extends RShape{constructor(t){super(t),this.setOptions(t)}render(t){const{x1:s,y1:i,x2:r,y2:e}=this;t.beginPath(),t.moveTo(this.xDpr(s),this.xDpr(i)),t.lineTo(this.xDpr(r),this.xDpr(e)),t.stroke()}}class Polyline extends RShape{constructor(t){super(t),this.setOptions(t)}isOpen(){return!0}render(t){const s=this.points.length;if(!(!s||isNaN(this.points[s-1].y))){t.beginPath(),t.moveTo(this.xDpr(this.points[0].x),this.xDpr(this.points[0].y));for(let i=0;i<s;i++){const r=this.points[i];t.lineTo(this.xDpr(r.x),this.xDpr(r.y))}!this.isOpen()&&t.closePath(),this._renderPaintInOrder(t)}}}class Polygon extends Polyline{constructor(t){super(t),this.setOptions(t)}isOpen(){return!1}}class Text extends RShape{constructor(t){const s={...t,lineHeight:t.lineHeight||t.fontSize||14};super(s),this.text="",this.fontFamily="system-ui",this.fontWeight="normal",this.fontSize=12,this.underline=!1,this.overline=!1,this.linethrough=!1,this.textAlign="left",this.textBaseline="top",this.fontStyle="normal",this.lineHeight=14,this.textBackgroundColor="",this.charSpacing=0,this.direction="ltr",this.lineClamp=0,this.width=1/0,this.setOptions(s)}render(t){let s=0,i=[];t.save(),t.font=`${this.fontWeight} ${this.xDpr(this.fontSize)}px ${this.fontFamily}`,t.textBaseline="top",t.textAlign=this.textAlign,t.direction=this.direction,t.fillStyle=this.textBackgroundColor,[this.text].forEach((r,e)=>{let n=0;String(r).split("").forEach((o,c)=>{const h=String(r).slice(n,c+1);t.measureText(h).width<this.xDpr(this.width)?i[s]=h:(i[s+1]=o,n=c,s++)}),s++}),this.lineClamp&&i.length>this.lineClamp&&(i=i.slice(0,this.lineClamp),i[this.lineClamp-1]=i[this.lineClamp-1].slice(0,-1)+"..."),this._setFillStyles(t,this),i.forEach((r,e)=>{t.fillText(r,this.xDpr({left:this.left,start:this.left,right:this.left+this.width,end:this.left+this.width,center:this.left+this.width/2}[this.textAlign]||this.left),this.xDpr(this.top+this.lineHeight*e+(this.lineHeight-this.fontSize)/2))}),t.restore()}}class Triangle extends RShape{constructor(t){super(t),this.setOptions(t)}render(t){const s=this.xDpr(this.left),i=this.xDpr(this.top),r=this.xDpr(this.width),e=this.xDpr(this.height);t.beginPath(),t.moveTo(s+r/2,i),t.lineTo(s,i+e),t.lineTo(s+r,i+e),t.closePath(),this._renderPaintInOrder(t)}}const shapeHandler={circle:Circle,ellipse:Ellipse,rect:Rect,triangle:Triangle,polyline:Polyline,polygon:Polygon,line:Line,text:Text,image:ImageShape},d={background:"transparent",enableRetinaScaling:!0,imageSmoothingEnabled:!0,width:0,designWidth:0,height:0,radius:0};class Rubbing extends RObject{constructor(t){super(t),this.isRendering=0;const s={...d,...t};this.background=s.background,this.imageSmoothingEnabled=s.imageSmoothingEnabled,this.width=s.width,this.height=s.height,this.designWidth=s.designWidth||s.width,this.radius=s.radius,this.component=s.component,this.selector=s.selector,this.dpr=isWeb?window.devicePixelRatio:wx.getSystemInfoSync().pixelRatio}async init(){const t=await this.queryCanvas();this.canvas=t,this.ctx=t.getContext("2d"),this.retinaScale()}queryCanvas(){return new Promise((t,s)=>{if(isWeb){const i=document.querySelector(this.selector);i?t(i):s(i)}else(this.component||wx).createSelectorQuery().select(this.selector).fields({node:!0,size:!0}).exec(i=>{i[0]?t(i[0]):s(i)})})}retinaScale(){if(isWeb)this.canvas.style.width=this.width+"px",this.canvas.style.height=this.height+"px",this.nDpr=this.dpr,this.canvas.width=this.width*this.dpr,this.canvas.height=this.height*this.dpr;else{const t=wx.getSystemInfoSync();this.nDpr=this.dpr*t.screenWidth/this.designWidth,this.canvas.width=this.width/t.screenWidth/this.dpr*this.designWidth,this.canvas.height=this.height/t.screenWidth/this.dpr*this.designWidth}}clipCanvas(t){new Rect({left:0,top:0,width:this.width,height:this.height,fill:this.background,rx:this.radius,ry:this.radius,nDpr:this.nDpr}).render(t),t.clip()}clearContext(t){t.clearRect(0,0,this.canvas.width,this.canvas.height),this.clipCanvas(t)}async _renderObjects(t,s){for(let i=0;i<s.length;i++)s[i]&&await s[i].render(t)}renderCanvas(t){this.clearContext(t),t.save(),this._renderObjects(t,this.serialized),t.restore()}renderAll(){this.renderCanvas(this.ctx)}serialize(t){const s=t.map(i=>({...i,zIndex:i.zIndex||0})).sort((i,r)=>i.zIndex-r.zIndex).map(i=>{const r=shapeHandler[i.type];return new r(this.new(i,this))});this.serialized=s,this.renderAll()}loadFromJSON(t){this.serialize(t.objects)}}module.exports=Rubbing;
